{"version":3,"sources":["webpack:///static/18.3ed71342.chunk.js","webpack:///./catalog/essentials/dictionary/development.md?769e","webpack:///./catalog/essentials/dictionary/development.md"],"names":["webpackJsonp","804","module","exports","__webpack_require__","React","createReactClass","PageRenderer","__esModule","default","WrappedPageRenderer","displayName","getInitialState","content","componentWillMount","render","createElement","Object","assign","this","props","state","__catalog_loader__","825"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAAUC,EAAQC,EAASC,GCF7B,GAAIC,GAAQ,EAAQ,IAChBC,EAAmB,EAAQ,IAC3BC,EAAe,EAAQ,KAAWA,YAClCA,GAAaC,aACfD,EAAeA,EAAaE,QAE9B,IAAIC,GAAsBJ,GACxBK,YAAa,sBACbC,gBAAiB,WACf,OAAQC,QAAS,EAAQ,OAE3BC,mBAAoB,aAUpBC,OAAQ,WACN,MAAOV,GAAMW,cAAcT,EAAcU,OAAOC,UAAWC,KAAKC,OAAQP,QAASM,KAAKE,MAAMR,aAGhGH,GAAoBY,oBAAqB,EACzCpB,EAAOC,QAAUO,GDUfa,IACA,SAAUrB,EAAQC,GEtCxBD,EAAOC,QAAU","file":"static/18.3ed71342.chunk.js","sourcesContent":["webpackJsonp([18],{\n\n/***/ 804:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var React = __webpack_require__(15);\n    var createReactClass = __webpack_require__(45);\n    var PageRenderer = __webpack_require__(294).PageRenderer;\n    if (PageRenderer.__esModule) {\n      PageRenderer = PageRenderer.default;\n    }\n    var WrappedPageRenderer = createReactClass({\n      displayName: 'WrappedPageRenderer',\n      getInitialState: function() {\n        return {content: __webpack_require__(825)};\n      },\n      componentWillMount: function() {\n        var component = this;\n        if (false) {\n          module.hot.accept(\"!!../../../node_modules/raw-loader/index.js!./development.md\", function() {\n            component.setState({\n              content: require(\"!!../../../node_modules/raw-loader/index.js!./development.md\")\n            })\n          })\n        }\n      },\n      render: function() {\n        return React.createElement(PageRenderer, Object.assign({}, this.props, {content: this.state.content}));\n      }\n    });\n    WrappedPageRenderer.__catalog_loader__ = true;\n    module.exports = WrappedPageRenderer;\n  \n\n/***/ }),\n\n/***/ 825:\n/***/ (function(module, exports) {\n\nmodule.exports = \"# PIXEL: Design Dictionary\\n> *Style once, use everywhere.*\\n\\nA *Design Dictionary* uses design definitions to **define styles** once and use those styles on any platform or language. It provides a single place to create and edit your styles, and exports these properties to all the places you need - iOS, Android, CSS, JS, HTML, sketch files, style documentation, etc. It is available as a CLI through npm, but can also be used like any normal node module if you want to extend its functionality.\\n\\nWhen you are managing user experiences, it can be quite challenging to keep styles consistent and synchronized across multiple development platforms and devices.  At the same time, designers, developers, PMs and others must be able to have consistent and up-to-date style documentation to enable effective work and communication.  Even then, mistakes inevitably happen and the design may not be implemented accurately.  StyleDictionary solves this by automatically generating style definitions across all platforms from a single source - removing roadblocks, errors, and inefficiencies across your workflow.\\n\\nDictionary doesn't force your app to work within its paradigm or have opinions on how you design, develop, and structure your app's code. It simply provides you with SDKs for use in your existing codebases. Your generated Dictionary builds are **libraries not frameworks** — they are intended to complement, but not replace, your design workflow.\\n\\n### Requirements\\n1. Node & Npm\\n2. Current version of Chrome.\\nEverything else should be handled on install.\\n\\nWebserver runs on port 80. Sometimes port 80 can be an issue, requiring admin rights. Changing the webserver port, should not break anything.\\n\\n### Setup & Run\\n1. Clone codebae from > https://github.com/aaa-ncnu-ie/pixel-design-dictionary.git\\n2. Run > \\\"npm install\\\"\\n4. Run > \\\"npm run dictionary\\\"\\n5. Browser will auto launch & auto navigate to > \\\"http://127.0.0.1/styleguide/\\\"\\n\\nTerminating the webservers shouldn't be problematic; if they do not self-terminate when closing the process:\\nRun > \\\"killall -9 node\\\"\\n\\n\\n\\n**NOTE**:\\nThe pilot integration with PBE is underway.\\n\\n### About Design Definitions\\nIn a design system, people often use special entities called “design definitions” to store their “design decisions”. These entities are in the shape of key/value pairs, saved in specific file formats (usually JSON or YAML). These files are later used as input files, processed and transformed to generate different output files, with different formats, to be included and consumed by other projects and codebases.\\n\\nThis, for example, is how some design definition are used as Sass variables in the declaration of the styles for the <Button/> component:\\n\\n```code\\nlang: scss\\n---\\n.button {\\n    position: relative;\\n    display: block;\\n    width: 100%;\\n    min-height: $definition-button-height;\\n    margin: 0;\\n    padding: $definition-spacing-sm $definition-spacing-xxlg;\\n    border-radius: $definition-button-border-radius;\\n    text-align: center;\\n}\\n\\n// variants\\n\\n.button--stroke {\\n    border: $definition-button-border-width solid currentColor;\\n    background: transparent;\\n}\\n\\n.button--monochrome {\\n    border: $definition-button-border-width solid $definition-colour-gray;\\n    background: #fff;\\n    color: $definition-colour-black;\\n}\\n\\n// and other variants here\\n```\\n\\n## The Basics\\n__PIXEL's Design Dictionary has three parts:__\\n1. [Style properties](properties.md), organized in JSON files\\n1. Static assets (e.g. fonts, icons, images, sounds, etc.), organized into folders\\n1. [Configuration](config.md), defining the transformation of the properties and assets for each output platform\\n\\n__What a style dictionary does:__\\n1. Transforms style properties and assets into platform specific deliverables\\n1. Creates human readable artifacts (e.g. documentation, design libraries, etc)\\n\\n__Things you can build with a style dictionary:__\\n1. Styling files for any platform or language\\n1. Images and graphics\\n1. Sketch files\\n1. Documentation website\\n1. _Literally anything you want styles or style data in_\\n\\n** Raw values are transformed and formatted to meet the needs of any platform. **\\n\\nThe Design Dictionary's framework is fully extensible and modular so you can create any type of file from a style dictionary.\\nIf there is a new language, platform, or file type you need, you can easily extend the style dictionary framework to create the necessary files.\\n\\n***\\n\\nLet's say we have a couple web apps, plus native iOS & Android applications. Instead of each development effort being responsible for translating and implmenting design rules, we let the style dictionary be the single source of truth. But, we can't stop there.\\n1. The web developers have decided to only use colors defined as *hsla* & formatted as Sass variables in an **.scss** file.\\n2. While iOS development standards call for colors to be deinfed using **rgba** & formatted as **.json**\\n3. Finally, Android, wanting to be on the bleeding edge, defines colors using the **8 Digit Hex (AARRGGBB)** formatted as **.xml**.\\n\\n> Instead of hard coding this information in each platform/format, Design Dictionary will consume that single source of truth and output files for each platform.\\n\\n## Configuration Driven\\nA config file defines what executes and what to output when the style dictionary builds.\\n\\nBy default, Design Dictionary looks for a `config.json` file in the root of your package. You can also specify a custom location when you use the CLI. If you want a custom build system using the npm module, you can specify a custom location for a configuration file or use a plain Javascript object.\\n\\n## config.json\\n Here is a quick example:\\n```code\\nlang: json\\n---\\n{\\n  \\\"source\\\": [\\\"properties/**/*.json\\\"],\\n  \\\"platforms\\\": {\\n    \\\"scss\\\": {\\n      \\\"transformGroup\\\": \\\"scss\\\",\\n      \\\"prefix\\\": \\\"sd\\\",\\n      \\\"buildPath\\\": \\\"build/scss/\\\",\\n      \\\"files\\\": [{\\n        \\\"destination\\\": \\\"_variables.scss\\\",\\n        \\\"format\\\": \\\"scss/variables\\\"\\n      }],\\n      \\\"actions\\\": [\\\"copy_assets\\\"]\\n    },\\n    \\\"android\\\": {\\n      \\\"transforms\\\": [\\\"attribute/cti\\\", \\\"name/cti/snake\\\", \\\"color/hex\\\", \\\"size/remToSp\\\", \\\"size/remToDp\\\"],\\n      \\\"buildPath\\\": \\\"build/android/src/main/res/values/\\\",\\n      \\\"files\\\": [{\\n        \\\"destination\\\": \\\"style_dictionary_colors.xml\\\",\\n        \\\"format\\\": \\\"android/colors\\\"\\n      }]\\n    }\\n  }\\n}\\n```\\n***\\n\\n## Classification\\n#### Category - Type - Item - Subitem - State\\n\\n![](.README_images/19b096bc.png)\\n\\nThis classification is simply based on the nesting of the properties inside the JSON files. If we look at this code, for example:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\"\\n      }\\n    }\\n  }\\n}\\n```\\n\\nwhen we process it via the build command the resulting JSON is this:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"name\\\": \\\"button-border-width\\\",\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"original\\\": {\\n          \\\"value\\\": \\\"1px\\\"\\n        },\\n        \\\"attributes\\\": {\\n          \\\"category\\\": \\\"button\\\",\\n          \\\"type\\\": \\\"border\\\",\\n          \\\"item\\\": \\\"width\\\"\\n        },\\n        \\\"path\\\": [\\n          \\\"button\\\",\\n          \\\"border\\\",\\n          \\\"width\\\"\\n        ]\\n      }\\n    }\\n  }\\n}\\n```\\nAs you can see, the order in the nesting of the source JSON is automatically interpreted as logical tree/structure, and it’s used to build the name of the properties (e.g. ``$button-border-width`` and ``BUTTON_BORDER_WIDTH`` in this example) but also to associate them a set of predefined “CTI” attributes.\\n\\nWhile working with Design Dictionary, you will find this implicit CTI classification consistently across many helpers and functions.\\n\\n---\\n\\nEvery attribute that you associate to a property in a source JSON file is transparently and automatically passed down along the transformations and will appear in the output files.\\n\\nFor example, if you write this declaration:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"meta\\\": {\\n      \\\"description\\\": \\\"design definitions for the button component\\\"\\n    },\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"documentation\\\": {\\n          \\\"comment\\\": \\\"the width of the border\\\"\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n\\nthe generated JSON file is this:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"meta\\\": {\\n      \\\"description\\\": \\\"design definitions for the button component\\\"\\n    },\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"documentation\\\": {\\n          \\\"comment\\\": \\\"the width of the border\\\"\\n        },\\n        \\\"original\\\": {...},\\n        \\\"name\\\": \\\"button-border-width\\\",\\n        \\\"attributes\\\": {...},\\n        \\\"path\\\": [...]\\n      }\\n    }\\n  }\\n}\\n```\\nAs you can see, whatever you add in term of extra attributes to the original JSON files is preserved and passed down during the build process (of course, if the format of the generated file supports this kind of representation).\\n\\nThis means two important things: first, you can use it to associate meta-information to your definitions (for example, I use it to add documentation, comments and notes to them, to be shown in the style guide); second, you can create custom actions or transforms in your build process, where you can use these extra attributes to selectively decide if/how to process the values.\\n\\nOne last cool thing: if you simply add a ``comment`` property to a value, this is automatically added as a comment in the exported Scss file (actually, all the file formats that support comments):\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"comment\\\": \\\"this is a comment\\\"\\n      }\\n    }\\n  }\\n}\\n```\\n\\nwill generate\\n\\n```code\\nlang: scss\\n---\\n$button-border-width: 1px; // this is a comment\\n```\\n\\n***\\n\\n## The generated design definition files\\nSo when the dictionary builds, what are the final results? How do the generated design definition files look like? Well, here they are.\\n\\nThis is the output as Scss file for the web platform:\\n\\n```code\\nlang: scss\\n---\\n// ./dist/web/brand#1/definitions.scss\\n\\n$def-alias-color-brand-primary: #3B5998;\\n$def-alias-color-brand-secondary: #4267B2;\\n$def-avatar-size-xxsm: 36px;\\n...\\n```\\n\\nThis the ES6 JavaScript format file:\\n\\n```code\\nlang: scss\\n---\\n// ./dist/web/brand#1/definitions.es6.js\\nexport const DEF_ALIAS_COLOR_BRAND_PRIMARY = '#3B5998';\\nexport const DEF_ALIAS_COLOR_BRAND_SECONDARY = '#4267B2';\\nexport const DEF_AVATAR_SIZE_XXSM = '36px';\\n...\\n```\\n\\nAnd this the flat JSON file:\\n\\n```code\\nlang: json\\n---\\n// ./dist/web/brand#1/definitions.json\\n[\\n  {\\n    \\\"value\\\": \\\"#3B5998\\\",\\n    \\\"type\\\": \\\"color\\\",\\n    \\\"comment\\\": \\\"this is a comment\\\",\\n    \\\"original\\\": {\\n      \\\"value\\\": \\\"#3B5998\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"comment\\\": \\\"this is a comment\\\"\\n    },\\n    \\\"name\\\": \\\"definition-alias-color-brand-primary\\\",\\n    \\\"attributes\\\": {\\n      \\\"category\\\": \\\"alias\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"item\\\": \\\"brand\\\",\\n      \\\"subitem\\\": \\\"primary\\\"\\n    },\\n    \\\"path\\\": [\\n      \\\"alias\\\",\\n      \\\"color\\\",\\n      \\\"brand\\\",\\n      \\\"primary\\\"\\n    ]\\n  },\\n  {\\n    \\\"value\\\": \\\"#4267B2\\\",\\n    \\\"type\\\": \\\"color\\\",\\n    \\\"comment\\\": \\\"this one is a comment too\\\",\\n    \\\"original\\\": {\\n      \\\"value\\\": \\\"#4267B2\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"comment\\\": \\\"this one is a comment too\\\"\\n    },\\n    \\\"name\\\": \\\"definition-alias-color-brand-secondary\\\",\\n    \\\"attributes\\\": {\\n      \\\"category\\\": \\\"alias\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"item\\\": \\\"brand\\\",\\n      \\\"subitem\\\": \\\"secondary\\\"\\n    },\\n    \\\"path\\\": [\\n      \\\"alias\\\",\\n      \\\"color\\\",\\n      \\\"brand\\\",\\n      \\\"secondary\\\"\\n    ]\\n  },\\n  {\\n    \\\"value\\\": \\\"36px\\\",\\n    \\\"original\\\": {\\n      \\\"value\\\": \\\"36px\\\"\\n    },\\n    \\\"name\\\": \\\"definition-avatar-size-xxsm\\\",\\n    \\\"attributes\\\": {\\n      \\\"category\\\": \\\"avatar\\\",\\n      \\\"type\\\": \\\"size\\\",\\n      \\\"item\\\": \\\"xxsm\\\"\\n    },\\n    \\\"path\\\": [\\n      \\\"avatar\\\",\\n      \\\"size\\\",\\n      \\\"xxsm\\\"\\n    ]\\n  },\\n  ...\\n]\\n```\\n\\nAs you can see, the flat JSON file exposes all the extra properties and meta-informations attached to the design definition properties, and makes the design definitions ready to be further consumed/processed by other tools (eg. a style guide, like in our case) in a very simple and straightforward way.\\n\\nSimilarly, for the native platforms, this is the output format for iOS:\\n\\n```code\\nlang: js\\n---\\n// ./dist/ios/brand#1/definitions-all.plist\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n<plist version=\\\"1.0\\\">\\n<dict>\\n    <key>defAliasColorBrandPrimary</key><string>#3B5998</string>\\n    <key>defAliasColorBrandSecondary</key><string>#4267B2</string>\\n    <key>defAvatarSizeXxsm</key><string>36pt</string>\\n    ...\\n</dict>\\n```\\n\\nAnd this is the output for Android:\\n\\n```code\\nlang: js\\n---\\n// ./dist/android/brand#1/definitions-all.xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<resources>\\n    <color name=\\\"def_alias_color_brand_primary\\\">#3B5998</color>\\n    <color name=\\\"def_alias_color_brand_secondary\\\">#4267B2</color>\\n    <item name=\\\"def_avatar_size_xxsm\\\" type=\\\"dimen\\\">36dp</item>    ...\\n</resources>\\n```\\n\\nAs you can see, for the native platforms I have converted the px values to pt/dp, while I have left the color values expressed in hex format. This is because both our iOS and Android application projects have already in place custom functions that can read hex values from PLIST and XML “style” files. Of course, this format is very specific to us, and you may need completely different formats. Before starting, I suggest you to speak with your iOS/Android developers and agree on which one is the best format for them (this may require the creation of custom formats/transforms/templates, as discussed above).\\n\"\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/18.3ed71342.chunk.js","\n    var React = require('react');\n    var createReactClass = require('create-react-class');\n    var PageRenderer = require('catalog').PageRenderer;\n    if (PageRenderer.__esModule) {\n      PageRenderer = PageRenderer.default;\n    }\n    var WrappedPageRenderer = createReactClass({\n      displayName: 'WrappedPageRenderer',\n      getInitialState: function() {\n        return {content: require(\"!!../../../node_modules/raw-loader/index.js!./development.md\")};\n      },\n      componentWillMount: function() {\n        var component = this;\n        if (module.hot) {\n          module.hot.accept(\"!!../../../node_modules/raw-loader/index.js!./development.md\", function() {\n            component.setState({\n              content: require(\"!!../../../node_modules/raw-loader/index.js!./development.md\")\n            })\n          })\n        }\n      },\n      render: function() {\n        return React.createElement(PageRenderer, Object.assign({}, this.props, {content: this.state.content}));\n      }\n    });\n    WrappedPageRenderer.__catalog_loader__ = true;\n    module.exports = WrappedPageRenderer;\n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./catalog/essentials/dictionary/development.md\n// module id = 804\n// module chunks = 18","module.exports = \"# PIXEL: Design Dictionary\\n> *Style once, use everywhere.*\\n\\nA *Design Dictionary* uses design definitions to **define styles** once and use those styles on any platform or language. It provides a single place to create and edit your styles, and exports these properties to all the places you need - iOS, Android, CSS, JS, HTML, sketch files, style documentation, etc. It is available as a CLI through npm, but can also be used like any normal node module if you want to extend its functionality.\\n\\nWhen you are managing user experiences, it can be quite challenging to keep styles consistent and synchronized across multiple development platforms and devices.  At the same time, designers, developers, PMs and others must be able to have consistent and up-to-date style documentation to enable effective work and communication.  Even then, mistakes inevitably happen and the design may not be implemented accurately.  StyleDictionary solves this by automatically generating style definitions across all platforms from a single source - removing roadblocks, errors, and inefficiencies across your workflow.\\n\\nDictionary doesn't force your app to work within its paradigm or have opinions on how you design, develop, and structure your app's code. It simply provides you with SDKs for use in your existing codebases. Your generated Dictionary builds are **libraries not frameworks** — they are intended to complement, but not replace, your design workflow.\\n\\n### Requirements\\n1. Node & Npm\\n2. Current version of Chrome.\\nEverything else should be handled on install.\\n\\nWebserver runs on port 80. Sometimes port 80 can be an issue, requiring admin rights. Changing the webserver port, should not break anything.\\n\\n### Setup & Run\\n1. Clone codebae from > https://github.com/aaa-ncnu-ie/pixel-design-dictionary.git\\n2. Run > \\\"npm install\\\"\\n4. Run > \\\"npm run dictionary\\\"\\n5. Browser will auto launch & auto navigate to > \\\"http://127.0.0.1/styleguide/\\\"\\n\\nTerminating the webservers shouldn't be problematic; if they do not self-terminate when closing the process:\\nRun > \\\"killall -9 node\\\"\\n\\n\\n\\n**NOTE**:\\nThe pilot integration with PBE is underway.\\n\\n### About Design Definitions\\nIn a design system, people often use special entities called “design definitions” to store their “design decisions”. These entities are in the shape of key/value pairs, saved in specific file formats (usually JSON or YAML). These files are later used as input files, processed and transformed to generate different output files, with different formats, to be included and consumed by other projects and codebases.\\n\\nThis, for example, is how some design definition are used as Sass variables in the declaration of the styles for the <Button/> component:\\n\\n```code\\nlang: scss\\n---\\n.button {\\n    position: relative;\\n    display: block;\\n    width: 100%;\\n    min-height: $definition-button-height;\\n    margin: 0;\\n    padding: $definition-spacing-sm $definition-spacing-xxlg;\\n    border-radius: $definition-button-border-radius;\\n    text-align: center;\\n}\\n\\n// variants\\n\\n.button--stroke {\\n    border: $definition-button-border-width solid currentColor;\\n    background: transparent;\\n}\\n\\n.button--monochrome {\\n    border: $definition-button-border-width solid $definition-colour-gray;\\n    background: #fff;\\n    color: $definition-colour-black;\\n}\\n\\n// and other variants here\\n```\\n\\n## The Basics\\n__PIXEL's Design Dictionary has three parts:__\\n1. [Style properties](properties.md), organized in JSON files\\n1. Static assets (e.g. fonts, icons, images, sounds, etc.), organized into folders\\n1. [Configuration](config.md), defining the transformation of the properties and assets for each output platform\\n\\n__What a style dictionary does:__\\n1. Transforms style properties and assets into platform specific deliverables\\n1. Creates human readable artifacts (e.g. documentation, design libraries, etc)\\n\\n__Things you can build with a style dictionary:__\\n1. Styling files for any platform or language\\n1. Images and graphics\\n1. Sketch files\\n1. Documentation website\\n1. _Literally anything you want styles or style data in_\\n\\n** Raw values are transformed and formatted to meet the needs of any platform. **\\n\\nThe Design Dictionary's framework is fully extensible and modular so you can create any type of file from a style dictionary.\\nIf there is a new language, platform, or file type you need, you can easily extend the style dictionary framework to create the necessary files.\\n\\n***\\n\\nLet's say we have a couple web apps, plus native iOS & Android applications. Instead of each development effort being responsible for translating and implmenting design rules, we let the style dictionary be the single source of truth. But, we can't stop there.\\n1. The web developers have decided to only use colors defined as *hsla* & formatted as Sass variables in an **.scss** file.\\n2. While iOS development standards call for colors to be deinfed using **rgba** & formatted as **.json**\\n3. Finally, Android, wanting to be on the bleeding edge, defines colors using the **8 Digit Hex (AARRGGBB)** formatted as **.xml**.\\n\\n> Instead of hard coding this information in each platform/format, Design Dictionary will consume that single source of truth and output files for each platform.\\n\\n## Configuration Driven\\nA config file defines what executes and what to output when the style dictionary builds.\\n\\nBy default, Design Dictionary looks for a `config.json` file in the root of your package. You can also specify a custom location when you use the CLI. If you want a custom build system using the npm module, you can specify a custom location for a configuration file or use a plain Javascript object.\\n\\n## config.json\\n Here is a quick example:\\n```code\\nlang: json\\n---\\n{\\n  \\\"source\\\": [\\\"properties/**/*.json\\\"],\\n  \\\"platforms\\\": {\\n    \\\"scss\\\": {\\n      \\\"transformGroup\\\": \\\"scss\\\",\\n      \\\"prefix\\\": \\\"sd\\\",\\n      \\\"buildPath\\\": \\\"build/scss/\\\",\\n      \\\"files\\\": [{\\n        \\\"destination\\\": \\\"_variables.scss\\\",\\n        \\\"format\\\": \\\"scss/variables\\\"\\n      }],\\n      \\\"actions\\\": [\\\"copy_assets\\\"]\\n    },\\n    \\\"android\\\": {\\n      \\\"transforms\\\": [\\\"attribute/cti\\\", \\\"name/cti/snake\\\", \\\"color/hex\\\", \\\"size/remToSp\\\", \\\"size/remToDp\\\"],\\n      \\\"buildPath\\\": \\\"build/android/src/main/res/values/\\\",\\n      \\\"files\\\": [{\\n        \\\"destination\\\": \\\"style_dictionary_colors.xml\\\",\\n        \\\"format\\\": \\\"android/colors\\\"\\n      }]\\n    }\\n  }\\n}\\n```\\n***\\n\\n## Classification\\n#### Category - Type - Item - Subitem - State\\n\\n![](.README_images/19b096bc.png)\\n\\nThis classification is simply based on the nesting of the properties inside the JSON files. If we look at this code, for example:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\"\\n      }\\n    }\\n  }\\n}\\n```\\n\\nwhen we process it via the build command the resulting JSON is this:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"name\\\": \\\"button-border-width\\\",\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"original\\\": {\\n          \\\"value\\\": \\\"1px\\\"\\n        },\\n        \\\"attributes\\\": {\\n          \\\"category\\\": \\\"button\\\",\\n          \\\"type\\\": \\\"border\\\",\\n          \\\"item\\\": \\\"width\\\"\\n        },\\n        \\\"path\\\": [\\n          \\\"button\\\",\\n          \\\"border\\\",\\n          \\\"width\\\"\\n        ]\\n      }\\n    }\\n  }\\n}\\n```\\nAs you can see, the order in the nesting of the source JSON is automatically interpreted as logical tree/structure, and it’s used to build the name of the properties (e.g. ``$button-border-width`` and ``BUTTON_BORDER_WIDTH`` in this example) but also to associate them a set of predefined “CTI” attributes.\\n\\nWhile working with Design Dictionary, you will find this implicit CTI classification consistently across many helpers and functions.\\n\\n---\\n\\nEvery attribute that you associate to a property in a source JSON file is transparently and automatically passed down along the transformations and will appear in the output files.\\n\\nFor example, if you write this declaration:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"meta\\\": {\\n      \\\"description\\\": \\\"design definitions for the button component\\\"\\n    },\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"documentation\\\": {\\n          \\\"comment\\\": \\\"the width of the border\\\"\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n\\nthe generated JSON file is this:\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"meta\\\": {\\n      \\\"description\\\": \\\"design definitions for the button component\\\"\\n    },\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"documentation\\\": {\\n          \\\"comment\\\": \\\"the width of the border\\\"\\n        },\\n        \\\"original\\\": {...},\\n        \\\"name\\\": \\\"button-border-width\\\",\\n        \\\"attributes\\\": {...},\\n        \\\"path\\\": [...]\\n      }\\n    }\\n  }\\n}\\n```\\nAs you can see, whatever you add in term of extra attributes to the original JSON files is preserved and passed down during the build process (of course, if the format of the generated file supports this kind of representation).\\n\\nThis means two important things: first, you can use it to associate meta-information to your definitions (for example, I use it to add documentation, comments and notes to them, to be shown in the style guide); second, you can create custom actions or transforms in your build process, where you can use these extra attributes to selectively decide if/how to process the values.\\n\\nOne last cool thing: if you simply add a ``comment`` property to a value, this is automatically added as a comment in the exported Scss file (actually, all the file formats that support comments):\\n\\n```code\\nlang: json\\n---\\n{\\n  \\\"button\\\": {\\n    \\\"border\\\": {\\n      \\\"width\\\": {\\n        \\\"value\\\": \\\"1px\\\",\\n        \\\"comment\\\": \\\"this is a comment\\\"\\n      }\\n    }\\n  }\\n}\\n```\\n\\nwill generate\\n\\n```code\\nlang: scss\\n---\\n$button-border-width: 1px; // this is a comment\\n```\\n\\n***\\n\\n## The generated design definition files\\nSo when the dictionary builds, what are the final results? How do the generated design definition files look like? Well, here they are.\\n\\nThis is the output as Scss file for the web platform:\\n\\n```code\\nlang: scss\\n---\\n// ./dist/web/brand#1/definitions.scss\\n\\n$def-alias-color-brand-primary: #3B5998;\\n$def-alias-color-brand-secondary: #4267B2;\\n$def-avatar-size-xxsm: 36px;\\n...\\n```\\n\\nThis the ES6 JavaScript format file:\\n\\n```code\\nlang: scss\\n---\\n// ./dist/web/brand#1/definitions.es6.js\\nexport const DEF_ALIAS_COLOR_BRAND_PRIMARY = '#3B5998';\\nexport const DEF_ALIAS_COLOR_BRAND_SECONDARY = '#4267B2';\\nexport const DEF_AVATAR_SIZE_XXSM = '36px';\\n...\\n```\\n\\nAnd this the flat JSON file:\\n\\n```code\\nlang: json\\n---\\n// ./dist/web/brand#1/definitions.json\\n[\\n  {\\n    \\\"value\\\": \\\"#3B5998\\\",\\n    \\\"type\\\": \\\"color\\\",\\n    \\\"comment\\\": \\\"this is a comment\\\",\\n    \\\"original\\\": {\\n      \\\"value\\\": \\\"#3B5998\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"comment\\\": \\\"this is a comment\\\"\\n    },\\n    \\\"name\\\": \\\"definition-alias-color-brand-primary\\\",\\n    \\\"attributes\\\": {\\n      \\\"category\\\": \\\"alias\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"item\\\": \\\"brand\\\",\\n      \\\"subitem\\\": \\\"primary\\\"\\n    },\\n    \\\"path\\\": [\\n      \\\"alias\\\",\\n      \\\"color\\\",\\n      \\\"brand\\\",\\n      \\\"primary\\\"\\n    ]\\n  },\\n  {\\n    \\\"value\\\": \\\"#4267B2\\\",\\n    \\\"type\\\": \\\"color\\\",\\n    \\\"comment\\\": \\\"this one is a comment too\\\",\\n    \\\"original\\\": {\\n      \\\"value\\\": \\\"#4267B2\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"comment\\\": \\\"this one is a comment too\\\"\\n    },\\n    \\\"name\\\": \\\"definition-alias-color-brand-secondary\\\",\\n    \\\"attributes\\\": {\\n      \\\"category\\\": \\\"alias\\\",\\n      \\\"type\\\": \\\"color\\\",\\n      \\\"item\\\": \\\"brand\\\",\\n      \\\"subitem\\\": \\\"secondary\\\"\\n    },\\n    \\\"path\\\": [\\n      \\\"alias\\\",\\n      \\\"color\\\",\\n      \\\"brand\\\",\\n      \\\"secondary\\\"\\n    ]\\n  },\\n  {\\n    \\\"value\\\": \\\"36px\\\",\\n    \\\"original\\\": {\\n      \\\"value\\\": \\\"36px\\\"\\n    },\\n    \\\"name\\\": \\\"definition-avatar-size-xxsm\\\",\\n    \\\"attributes\\\": {\\n      \\\"category\\\": \\\"avatar\\\",\\n      \\\"type\\\": \\\"size\\\",\\n      \\\"item\\\": \\\"xxsm\\\"\\n    },\\n    \\\"path\\\": [\\n      \\\"avatar\\\",\\n      \\\"size\\\",\\n      \\\"xxsm\\\"\\n    ]\\n  },\\n  ...\\n]\\n```\\n\\nAs you can see, the flat JSON file exposes all the extra properties and meta-informations attached to the design definition properties, and makes the design definitions ready to be further consumed/processed by other tools (eg. a style guide, like in our case) in a very simple and straightforward way.\\n\\nSimilarly, for the native platforms, this is the output format for iOS:\\n\\n```code\\nlang: js\\n---\\n// ./dist/ios/brand#1/definitions-all.plist\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n<plist version=\\\"1.0\\\">\\n<dict>\\n    <key>defAliasColorBrandPrimary</key><string>#3B5998</string>\\n    <key>defAliasColorBrandSecondary</key><string>#4267B2</string>\\n    <key>defAvatarSizeXxsm</key><string>36pt</string>\\n    ...\\n</dict>\\n```\\n\\nAnd this is the output for Android:\\n\\n```code\\nlang: js\\n---\\n// ./dist/android/brand#1/definitions-all.xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<resources>\\n    <color name=\\\"def_alias_color_brand_primary\\\">#3B5998</color>\\n    <color name=\\\"def_alias_color_brand_secondary\\\">#4267B2</color>\\n    <item name=\\\"def_avatar_size_xxsm\\\" type=\\\"dimen\\\">36dp</item>    ...\\n</resources>\\n```\\n\\nAs you can see, for the native platforms I have converted the px values to pt/dp, while I have left the color values expressed in hex format. This is because both our iOS and Android application projects have already in place custom functions that can read hex values from PLIST and XML “style” files. Of course, this format is very specific to us, and you may need completely different formats. Before starting, I suggest you to speak with your iOS/Android developers and agree on which one is the best format for them (this may require the creation of custom formats/transforms/templates, as discussed above).\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/raw-loader!./catalog/essentials/dictionary/development.md\n// module id = 825\n// module chunks = 18"],"sourceRoot":""}